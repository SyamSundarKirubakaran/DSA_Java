Array Problems:
- [ ] One -> Linear Search
- [ ] Two -> Binary Search
- [ ] Three -> Find a pair in an array whose sum is equal to given number (Hash Approach) - Brute Force, Quick Sort and search complement, Hash Table
- [ ] Four -> Element that occurs more than n/2 times - Unsorted
- [ ] Five -> Element that occurs more than n/2 times - Sorted
- [ ] Six -> Largest Difference such that the smaller number appears before larger number - Maximum Sum Sub-array
- [ ] Seven -> Largest Difference such that the smaller number appears before larger number - Maximum Sum Sub-array - Less space complexity
- [ ] Eight -> Largest Difference such that the smaller number appears before larger number - Min So Far
- [ ] Nine -> Find the number occurring odd number of times in the given array(Only one element occurs odd number of times)
- [ ] Ten -> Separate 0's and 1's in an array
- [ ] Eleven -> Separate Even and Odd numbers in an array
- [ ] Twelve -> 2 elements whose sum is close to zero - either positive or negative
- [ ] Thirteen -> 3 elements such that their sum is equal to x.
- [ ] Fourteen -> Find the Equilibrium Index .i.e., left sum and right sum of index should be equal.
- [ ] Fifteen -> Find the Equilibrium Index .i.e., left sum and right sum of index should be equal - Less Space Complexity.
- [ ] Sixteen -> Array of unknown size.0s followed by 1s find the first index of 1
- [ ] Seventeen -> Maximum of every contiguous sub-array of size k. - Sliding Window.
- [ ] Eighteen -> count the no.of smaller elements to the right of each element in the array.
- [ ] Nineteen -> Largest Multiple of 3 with given digits.
- [ ] Twenty -> Sub Array Sum equal to x
- [ ] TwentyOne -> Find Sub Array whose sum is equals zero
- [ ] TwentyTwo -> Largest sub array with equal no.of zeros and ones
- [ ] TwentyThree -> Construct a product array such that the ith element in product array contains the product of all the remaining elements but i (Without Division)
- [ ] TwentyFour -> Construct a product array such that the ith element in product array contains the product of all the remaining elements but i (Without Division) - less time complexity
- [ ] TwentyFive -> Sort a nearly sorted array, each element can be misplaced by a max of k digits before or after
- [ ] TwentySix -> Find Duplicates in O(n) time and O(1) space - Array element values are <= Max Index
- [ ] TwentySeven -> Find 2 repeating elements in a given array - XOR - Given (n+2) elements - 1 ≤ a[i] ≤ n - All elements from 1 to n occurs at least once (Except the 2 numbers that occurs twice)
- [ ] TwentyEight -> Rotate an array of size n by d elements - Left rotation - Beginning to End - Juggling Algorithm
- [ ] TwentyNine -> Sort array in wave form - Even position number
- [ ] Thirty -> Next least greater number to the given number, input as digit array - with same digits
- [ ] ThirtyOne -> Trapping Rain Water Problem
- [ ] ThirtyTwo -> No.of Triangles that can be formed
- [ ] ThirtyThree -> Smallest number that can't be formed from the array of given numbers
- [ ] ThirtyFour -> Rearrange such that a[i] becomes a[a[i]]
- [ ] ThirtyFive -> Rotate Matrix by 90 degree - anti-clockwise

Tree Problems:
- [ ] One -> Size of a Binary Tree
- [ ] Two -> Identical or not
- [ ] Three -> Mirror Tree
- [ ] Four -> Level Order Traversal
- [ ] Five -> Lowest Common Ancestor (LCA) - BST
- [ ] Six -> Lowest Common Ancestor (LCA) - Binary Tree
- [ ] Seven -> Binary Tree into DLL - IN order - InPlace conversion
- [ ] Eight -> Diameter of the Binary Tree
- [ ] Nine -> Find the level of a given node
- [ ] Ten -> Print nodes at k distance form root
- [ ] Eleven -> Print nodes at K distance form any node in BT
- [ ] Twelve -> Vertical Tree Order Traversal
- [ ] Thirteen -> Vertical Sum of the Binary Tree
- [ ] Fourteen -> Sum Tree or not
- [ ] Fifteen -> Top View
- [ ] Sixteen -> Bottom View
- [ ] Seventeen -> Left View
- [ ] Eighteen -> Remove all paths whose length < K in BT.
- [ ] Nineteen -> One BT is a sub tree of another BT or not
- [ ] Twenty -> Cousin Nodes or not
- [ ] TwentyOne -> Balanced BST construction from a sorted List
- [ ] TwentyTwo -> BST into Balanced BST
- [ ] TwentyThree -> Print all paths possible from root to all leaves
- [ ] TwentyFour -> Spiral Level Order Traversal
- [ ] TwentyFive -> BT construction from the given POST and IN Order
- [ ] TwentySix -> All nodes at K distance from leaf
- [ ] TwentySeven -> Expression Evaluation
- [ ] TwentyEight -> Extreme nodes of each level in alternating order
- [ ] TwentyNine -> Diagonal Traversal BT
- [ ] Thirty -> BT to a BT that holds Child sum property
- [ ] ThirtyOne -> Multiplication of Sums of data of leaves at same level
- [ ] ThirtyTwo -> Multiplication of Sums of data at same level
- [ ] ThirtyThree -> Max of all differences of a node and it's ancestors BT
- [ ] ThirtyFour -> Serialization and Deserialization BT
- [ ] ThirtyFive -> Serialization and Deserialization n-ary Tree
- [ ] ThirtySix -> Tree from ancestor Matrix
- [ ] ThirtySeven -> Complete Binary Tree from a LL
- [ ] ThirtyEight -> Find the next right node of a given node in the same level
- [ ] ThirtyNine -> Boundary Traversal
- [ ] Forty -> Convert a given tree into sum tree
- [ ] FortyOne -> Check if Foldable or not
- [ ] FortyTwo -> Check if removing an edge will cut into two equal halves
- [ ] FortyThree -> Locking and Unlocking a Node - Design Problem
- [ ] FortyFour -> Reverse Alternate Levels of a perfect BT
- [ ] FortyFive -> Custom Tree Print Problem
- [ ] FortySix -> Threaded BT

Linked List Problems:
- [ ] One -> Reverse a LL
- [ ] Two -> Middle of a LL
- [ ] Three -> Kth node from the end of the LL
- [ ] Four -> Detect loop in LL
- [ ] Five -> Find the start of the Loop in the LL with Loop
- [ ] Six -> 2 LL merge at a point, find that point
- [ ] Seven -> Alternating Split
- [ ] Eight -> Clone a LL that contains Random Pointer (Custom LL)
- [ ] Nine -> Palindrome of a LL
- [ ] Ten -> Merge 2 Sorted LL into one Sorted LL
- [ ] Eleven -> Merge K sorted LL of size N into single Sorted LL of size kn
- [ ] Twelve -> Merge sort on LL
- [ ] Thirteen -> LL with arb-pointer pointing to greatest in the right side of the current node
- [ ] Fourteen -> Memory efficient DLL
- [ ] Fifteen -> Sort a LL with 0s, 1s and 2s
- [ ] Sixteen -> Add 1 to number represented as LL


