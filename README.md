
![image](./img/Java_banner.jpg)

## Topics:
- [Arrays](#Array-Problems)
- [Trees](#Tree-Problems)
- [Linked List](#Linked-List-Problems)
- [Stack](#Stack-Problems)
- [Queue](#Queue-Problems)
- [Dynamic Programming](#Dynamic-Programming)
- [Greedy Problems](#Greedy-Problems)
- [Divide and Conquer](#Divide-and-Conquer)
- [Bit Manipulation](#Bit-Manipulation)
- [Mathematical](#Mathematical)
- [Hashing](#Hashing)
- [String](#Strings)
- [Pattern Matching](#Pattern-Matching)
- [Heaps](#Heaps)
- [Back Tracking](#Back-Tracking)
- [Graphs](#Graph-Problems)
- [Workouts](#Workouts)

## Array Problems
- [ ] A -> Linear Search
- [ ] B -> Binary Search
- [ ] C -> Find a pair in an array whose sum is equal to given number (Hash Approach) - Brute Force, Quick Sort and search complement, Hash Table
- [ ] D -> Element that occurs more than n/2 times - Unsorted - Moore's Voting Algorithm, but using quick sort followed by count [or] HashMap
- [ ] E -> Element that occurs more than n/2 times - Sorted
- [ ] F -> Largest Difference such that the smaller number appears before larger number
- [ ] G -> Largest Difference such that the smaller number appears before larger number - Less space complexity
- [ ] H -> Largest Difference such that the smaller number appears before larger number - Min So Far
- [ ] I -> Find the number occurring odd number of times in the given array(Only one element occurs odd number of times)
- [ ] J -> Separate 0's and 1's in an array
- [ ] K -> Separate Even and Odd numbers in an array
- [ ] L -> 2 elements whose sum is close to zero - either positive or negative
- [ ] M -> 3 elements such that their sum is equal to x.
- [ ] N -> Find the Equilibrium Index .i.e., left sum and right sum of index should be equal.
- [ ] O -> Find the Equilibrium Index .i.e., left sum and right sum of index should be equal - Less Space Complexity.
- [ ] P -> Array of unknown size. 0s followed by 1s find the first index of 1
- [ ] Q -> Maximum of every contiguous sub-array of size k. - Sliding Window.
- [ ] R -> count the no.of smaller elements to the right of each element in the array.
- [ ] S -> Largest Multiple of 3 with given digits.
- [ ] T -> Sub Array Sum equal to x
- [ ] U -> Find Sub Array whose sum is equals zero
- [ ] V -> Largest sub array with equal no.of zeros and ones
- [ ] W -> Construct a product array such that the ith element in product array contains the product of all the remaining elements but i (Without Division)
- [ ] X -> Construct a product array such that the ith element in product array contains the product of all the remaining elements but i (Without Division) - less time complexity
- [ ] Y -> Sort a nearly sorted array, each element can be misplaced by a max of k digits before or after
- [ ] Z -> Find Duplicates in O(n) time and O(1) space - Array element values are ≤ Max Index
- [ ] ZA -> Find 2 repeating elements in a given array - XOR - Given (n+2) elements - 1 ≤ a[i] ≤ n - All elements from 1 to n occurs at least once (Except the 2 numbers that occurs twice)
- [ ] ZB -> Rotate an array of size n by d elements - Left rotation - Beginning to End - Juggling Algorithm
- [ ] ZC -> Sort array in wave form - Even position number
- [ ] ZD -> Next least greater number to the given number, input as digit array - with same digits
- [ ] ZE -> Trapping Rain Water Problem
- [ ] ZF -> No.of Triangles that can be formed
- [ ] ZG -> Smallest number that can't be formed by sum of given numbers
- [ ] ZH -> Rearrange such that a[i] becomes a[a[i]]
- [ ] ZI -> Rotate Matrix by 90 degree - anti-clockwise 
- [ ] ZJ -> Count number of occurrences (or frequency) in a sorted array
- [ ] ZK -> Find Sub Array whose sum is equals zero - reduced time complexity
- [ ] ZL -> Largest sub array with equal no.of zeros and ones - my way
- [ ] ZM -> Find Duplicates in O(n) time and O(1) space - Array element values are ≤ Max Index - GFG
- [ ] ZN -> Rotate an array of size n by d elements - Left rotation - Beginning to End 

## Tree Problems
- [ ] A -> Size of a Binary Tree
- [ ] B -> Identical or not
- [ ] C -> Mirror Tree
- [ ] D -> Level Order Traversal
- [ ] E -> Lowest Common Ancestor (LCA) - BST
- [ ] F -> Lowest Common Ancestor (LCA) - Binary Tree
- [ ] G -> Binary Tree into DLL - IN order - InPlace conversion
- [ ] H -> Diameter of the Binary Tree
- [ ] I -> Find the level of a given node
- [ ] J -> Print nodes at k distance form root
- [ ] K -> Print nodes at K distance from any node in BT
- [ ] L -> Vertical Tree Order Traversal
- [ ] M -> Vertical Sum of the Binary Tree
- [ ] N -> Sum Tree or not
- [ ] O -> Top View
- [ ] P -> Bottom View
- [ ] Q -> Left View
- [ ] R -> Remove all nodes whose length = K in BT.
- [ ] S -> One BT is a sub tree of another BT or not
- [ ] T -> Cousin Nodes or not
- [ ] U -> Balanced BST construction from a sorted List
- [ ] V -> Unbalanced BST into Balanced BST
- [ ] W -> Print all paths possible from root to all leaves
- [ ] X -> Spiral Level Order Traversal
- [ ] Y -> BT construction from the given POST and IN Order
- [ ] Z -> All nodes at K distance from leaf
- [ ] ZA -> Expression Evaluation
- [ ] ZB -> Extreme nodes of each level in alternating order
- [ ] ZC -> Diagonal Traversal BT
- [ ] ZD -> BT to a BT that holds Child sum property
- [ ] ZE -> Multiplication of Sums of data of leaves at same level
- [ ] ZF -> Multiplication of Sums of data at same level
- [ ] ZG -> Max of all differences of a node and it's ancestors BT
- [ ] ZH -> Serialization and Deserialization BT
- [ ] ZI -> Serialization and Deserialization n-ary Tree
- [ ] ZJ -> Tree from ancestor Matrix
- [ ] ZK -> Complete Binary Tree from a LL
- [ ] ZL -> Find the next right node of a given node in the same level
- [ ] ZM -> Boundary Traversal
- [ ] ZN -> Convert a given tree into sum tree
- [ ] ZO -> Check if Foldable or not
- [ ] ZP -> Check if removing an edge will cut into two equal halves
- [ ] ZQ -> Locking and Unlocking a Node - Design Problem
- [ ] ZR -> Reverse Alternate Levels of a perfect BT
- [ ] ZS -> Custom Tree Print Problem
- [ ] ZT -> Threaded BT
- [ ] ZU -> Remove all paths whose length < K in BT. -> Subsection of 18th Problem
- [ ] ZV -> BT construction from the given PRE and IN Order -> Subsection of 25th Problem

## Linked List Problems
- [ ] A -> Reverse a LL
- [ ] B -> Middle of a LL
- [ ] C -> Kth node from the end of the LL
- [ ] D -> Detect loop in LL
- [ ] E -> Find the start of the Loop in the LL with Loop
- [ ] F -> 2 LL merge at a point, find that point
- [ ] G -> Alternating Split
- [ ] H -> Clone a LL that contains Random Pointer (Custom LL)
- [ ] I -> Palindrome of a LL
- [ ] J -> Merge 2 Sorted LL into one Sorted LL
- [ ] K -> Merge K sorted LL of size N into single Sorted LL of size kn
- [ ] L -> Merge sort on LL
- [ ] M -> LL with arb-pointer pointing to greatest in the right side of the current node
- [ ] N -> Memory efficient DLL
- [ ] O -> Sort a LL with 0s, 1s and 2s
- [ ] P -> Add 1 to number represented as LL
- [ ] Q -> Merge K sorted LL of size N into single Sorted LL of size kn - Better complexity

## Stack Problems
- [ ] A -> Stack using Queues
- [ ] B -> getMin @ O(1)
- [ ] C -> Reverse a Stack
- [ ] D -> closest greater element to the right
- [ ] E -> Overlapping Intervals
- [ ] F -> Balancing Parenthesis
- [ ] G -> Stock Span Problem
- [ ] H -> Min no.of bracket reversals req to make the eqn balanced
- [ ] I -> find duplicate parenthesis present or not
- [ ] J -> Celebrity Problem

## Queue Problems
- [ ] A -> Circular tour that visit all gasoline stations before running out of gas

## Dynamic Programming
- [ ] A -> Maximum Sum Sub array
- [ ] B -> Maximum Sum Increasing Sub Sequence [OR] Longest increasing Sub Sequence
- [ ] C -> Longest Sub Sequence in an array such that the element are consecutive
- [ ] D -> In a Binary Matrix, Max Square Matrix with all 1s
- [ ] E -> Kth Ugly Number
- [ ] F -> Longest Increasing Sub Sequence
- [ ] G -> Longest Decreasing Sub Sequence
- [ ] H -> Perfect Hill Sequence
- [ ] I -> Edit Distance
- [ ] J -> Largest Sum Independent set in a Binary Tree
- [ ] K -> Find n-bit integer that doesn't have 2 consecutive zeros
- [ ] L -> Word breaking problem
- [ ] M -> Partition Problem - Sub Set Sum Problem
- [ ] N -> Longest Palindromic sub sequence
- [ ] O -> Steps 1 or 2 to reach n
- [ ] P -> Longest non overlapping repeating sub string
- [ ] Q -> Min cost to make strings(x and y) equal, del(x) -> S, del(y) -> P
- [ ] R -> No.of times a string appeared as Sub Sequence in other string
- [ ] S -> No.of ways to fill 2xn with 2x1
- [ ] T -> Given a Cost matrix, min cost to reach (m-1,n-1) from (0,0), allowed movements -> left, right, diagonally down
- [ ] U -> K palindrome - If string becomes palindrome or not by doing atmost k deletions
- [ ] V -> Longest Common Sub Sequence
- [ ] W -> Sum of all digits from 1 to n
- [ ] X -> Given a string of digits, sub string length = 2k, sum of left k = sum of right k
- [ ] Y -> Given a BT, find Largest Independent Set
- [ ] Z -> Cutting Rod
- [ ] ZA -> Longest Palindromic sub string
- [ ] ZB -> Count all Palindromic sub string in a string
- [ ] ZC -> Count all distinct Palindromic sub string in a string
- [ ] ZD -> Rectangular grid 2xn, max sum such that no 2 chosen digit are adj -> vertically, horizontally, diagonally
- [ ] ZE -> Arrays A -> m, B -> n, (m>n) insert(m-n) 0s in B such that dot product is max
- [ ] ZF -> Largest Independent Set
- [ ] ZG -> Egg Dropping Problem
- [ ] ZH -> No.of Non-decreasing numbers with n digits
- [ ] ZI -> Weighted Job Scheduling
- [ ] ZJ -> Count no.of ways to reach a score in a given game, player can score 2, 4 or 6 points
- [ ] ZK -> Max coins by busting balloons
- [ ] ZL -> Max points in the grid using 2 traversals
- [ ] ZM -> Sub Set Sum Problem
- [ ] ZN -> Matrix Chaining - Results Upper triangular Matrix
- [ ] ZO -> Longest Common Sub Sequence
- [ ] ZP -> Multi Stage Graph
- [ ] ZQ -> 0/1 Knapsack
- [ ] ZR -> Travelling Sales man (TSP) - DFS based - Hamiltonian Cycle + MIN Cost
- [ ] ZS -> All Pair Shortest path - Floyd Warshall's
- [ ] ZT -> Matrix Chaining - Top Down 
- [ ] ZU -> Coin Change Problem
- [ ] ZV -> Longest Palindromic sub string - Less Space Complexity
- [ ] ZW -> No.of Non-decreasing numbers with n digits - Less space

## Greedy Problems
- [ ] A -> n different ropes of different length, tie them up into a single rope with Min cost.
- [ ] B -> Maximum Non Overlapping Intervals
- [ ] C -> Min no.of platforms required to station all trains without collision
- [ ] D -> Rearrange the characters in the string such that same characters become d-distance away from each other.
- [ ] E -> Dijkstra's Algorithm
- [ ] F -> Fractional Knapsack
- [ ] G -> Huffman's Coding
- [ ] H -> Job Sequencing with Deadlines
- [ ] I -> Spanning Trees and kirchhoff's theorem
- [ ] J -> Minimum Spanning Tree - Prim's
- [ ] K -> Kruskal's Algorithm
- [ ] L -> Optimal Merge Patterns

## Divide and Conquer
- [ ] A -> Find the element that occurs more than n/2 times - Sorted Array.
- [ ] B -> Bolt and Nuts
- [ ] C -> Implement pow()
- [ ] D -> Search an element in a sorted Rotated Array
- [ ] E -> Count Inversions in an array
- [ ] F -> Missing number in arithmetic progression
- [ ] G -> Array containing 0s before 1s, count 1s
- [ ] H -> Array has 2n elements -> `a1, a2, a3, .., an, b1, b2, .. , bn` -> shuffle -> `a1, b1, a2, b2, .., an, bn`
- [ ] I -> Sorted Array of non-repeating elements, find if there's `i` for which `a[i] = i`
- [ ] J -> `a[0]..a[i]` -> increasing, `a[i+1]..a[n]` -> decreasing, find i
- [ ] K -> search for an element in a row-wise and column-wise sorted 2d array.
- [ ] L -> External Sorting
- [ ] M -> Find median of 2 sorted arrays
- [ ] N -> Find Peek Element
- [ ] O -> Get first 1.

## Bit Manipulation
- [ ] A -> Kth bit is set or not
- [ ] B -> set Kth Bit of a number
- [ ] C -> clear Kth bit of a number
- [ ] D -> Toggle Kth bit of a number
- [ ] E -> count the no.of set bits of a number
- [ ] F -> power of 2 or not
- [ ] G -> next higher number of the given number which is a power of 2
- [ ] H -> power of 4 or not
- [ ] I -> Multiply with 7 without using `*`
- [ ] J -> Check if a Number is Odd or Even using Bitwise Operators

## Mathematical
- [ ] A -> Prime or not
- [ ] B -> Print prime upto n - Sieve of Eratosthenes Algorithm
- [ ] C -> Lucky number or not

## Hashing
- [ ] A -> check if the array has duplicate entries at K distance or not
- [ ] B -> check if 2 sets are disjoint or not
- [ ] C -> Group all occurrences of elements order by their 1st occurrence.
- [ ] D -> Given an array A, count the distinct elements in all windows of size K
- [ ] E -> Given an array and a range (low, high). Find the elements that are in the range but not in the array.
- [ ] F -> Find the no.of sub arrays with sum zero
- [ ] G -> Find 4 elements i, j, k & l -> such that `i + j = k + l`

## Strings
- [ ] A -> Find a max occurring character in a given array.
- [ ] B -> Remove duplicates in a given string
- [ ] C -> Check if given 2 strings are rotations of each other
- [ ] D -> Reverse the words in the given sentence
- [ ] E -> Reverse a given string
- [ ] F -> Check if palindrome
- [ ] G -> Find 1st non-repeating character in the given string
- [ ] H -> Run length encoding
- [ ] I -> Anagrams
- [ ] J -> Excel column name for a given excel column number (MS Excel)
- [ ] K -> Find a smallest window in a string containing all characters of another string
- [ ] L -> Find 1s non-repeating character in a stream of characters
- [ ] M -> All combinations of strings used to dail a number (Old Phone Key pad)
- [ ] N -> Min no.of palindromic sub-sequences to be removed to empty a binary string
- [ ] O -> Check if given sequence of moves for robot is circular or not
- [ ] P -> Min and Max of an array using min no.of comparisons
- [ ] Q -> Convert one string to another using min no.of given operations
- [ ] R -> Print concatenation of zig-zack string in k-rows
- [ ] S -> Remove adj duplicate characters in a given string
- [ ] T -> Min no.of palindromic sub-sequences to be removed to empty a binary string - Tournament Method

## Pattern Matching
- [ ] A -> Find all occurrences of str2 in str1 - Brute force
- [ ] B -> Knuth Morris Pratt Algorithm
- [ ] C -> Boyer's Moore String Matching Algorithm
- [ ] D -> Rabin-Karp String Matching Algorithm
- [ ] E -> Find all occurrences of a given word in a matrix

## Heaps
- [ ] A -> Finding the max element in MIN heap
- [ ] B -> Deleting arb element in MIN heap
- [ ] C -> K-Largest elements from an array
- [ ] D -> Median in a stream of numbers
- [ ] E -> Given K-sorted list, find minimum range to which at least on number belongs from every list. - All list are of same size
- [ ] F -> Convert MAX heap into MIN Heap
- [ ] G -> Print out all integers of the form `a^3+b^3` where a & b are integers b/w 0 & n in sorted order.
- [ ] H -> Convert BST to MAX Heap
- [ ] I -> Find the Kth largest element in a stream
- [ ] J -> Tournament Tree
- [ ] K -> Print all elements in sorted order in row wise and column wise sorted matrix
- [ ] L -> Sort a nearly sorted array
- [ ] M -> Given n ropes with different length, connect with minimum cost.
- [ ] N -> Check if the given binary tree is a max heap or not.
- [ ] O -> Given K-sorted arrays of size n-each, merge them. - different sized inner lists
- [ ] P -> Delete root from a heap.

## Back Tracking
- [ ] A -> Print all permutations of given string
- [ ] B -> Print all the strings of n-bits
- [ ] C -> N-Queens Problem
- [ ] D -> Rat in Maze
- [ ] E -> Knight Tour Problem
- [ ] F -> Find subset of elements that are selected from a given set whose sum adds upto a given number `k` // Subset Sum Problem - Using Backtracking
- [ ] G -> SUDOKU
- [ ] H -> N-Queens Problem - Easy way

## Graph Problems
- [ ] A -> DFS
- [ ] B -> BFS
- [ ] C -> Find if there's a path between vi and vj in a directed graph
- [ ] D -> Undirected Graph, cycle or not
- [ ] E -> Bipartite or not
- [ ] F -> Detect a cycle in a directed graph
- [ ] G -> Print all jumping numbers smaller than or equal to given value(k)
- [ ] H -> Single source shortest path - DAG
- [ ] I -> Longest Path in DAG, no weights
- [ ] J -> Find Articulation Point / Cut Vertex, Undirected
- [ ] K -> Longest Path in DAG, with weights
- [ ] L -> Topological sort