
![image](./img/Java_banner.jpg)

## Topics:
- [Arrays](#Array-Problems)
- [Trees](#Tree-Problems)
- [Linked List](#Linked-List-Problems)
- [Stack](#Stack-Problems)
- [Queue](#Queue-Problems)
- [Dynamic Programming](#Dynamic-Programming)
- [Greedy Problems](#Greedy-Problems)
- [Divide and Conquer](#Divide-and-Conquer)
- [Bit Manipulation](#Bit-Manipulation)
- [Mathematical](#Mathematical)
- [Hashing](#Hashing)
- [String](#Strings)
- [Pattern Matching](#Pattern-Matching)
- [Heaps](#Heaps)
- [Back Tracking](#Back-Tracking)
- [Graphs](#Graph-Problems)
- [Workouts](#Workouts)

## Array Problems
- [ ] A - One -> Linear Search
- [ ] B - Two -> Binary Search
- [ ] C - Three -> Find a pair in an array whose sum is equal to given number (Hash Approach) - Brute Force, Quick Sort and search complement, Hash Table
- [ ] D - Four -> Element that occurs more than n/2 times - Unsorted - Moore's Voting Algorithm, but using quick sort followed by count [or] HashMap
- [ ] E - Five -> Element that occurs more than n/2 times - Sorted
- [ ] F - Six -> Largest Difference such that the smaller number appears before larger number
- [ ] G - Seven -> Largest Difference such that the smaller number appears before larger number - Less space complexity
- [ ] H - Eight -> Largest Difference such that the smaller number appears before larger number - Min So Far
- [ ] I - Nine -> Find the number occurring odd number of times in the given array(Only one element occurs odd number of times)
- [ ] J - Ten -> Separate 0's and 1's in an array
- [ ] K - Eleven -> Separate Even and Odd numbers in an array
- [ ] L - Twelve -> 2 elements whose sum is close to zero - either positive or negative
- [ ] M - Thirteen -> 3 elements such that their sum is equal to x.
- [ ] N - Fourteen -> Find the Equilibrium Index .i.e., left sum and right sum of index should be equal.
- [ ] O - Fifteen -> Find the Equilibrium Index .i.e., left sum and right sum of index should be equal - Less Space Complexity.
- [ ] P - Sixteen -> Array of unknown size. 0s followed by 1s find the first index of 1
- [ ] Q - Seventeen -> Maximum of every contiguous sub-array of size k. - Sliding Window.
- [ ] R - Eighteen -> count the no.of smaller elements to the right of each element in the array.
- [ ] S - Nineteen -> Largest Multiple of 3 with given digits.
- [ ] T - Twenty -> Sub Array Sum equal to x
- [ ] U - TwentyOne -> Find Sub Array whose sum is equals zero
- [ ] V - TwentyTwo -> Largest sub array with equal no.of zeros and ones
- [ ] W - TwentyThree -> Construct a product array such that the ith element in product array contains the product of all the remaining elements but i (Without Division)
- [ ] X - TwentyFour -> Construct a product array such that the ith element in product array contains the product of all the remaining elements but i (Without Division) - less time complexity
- [ ] Y - TwentyFive -> Sort a nearly sorted array, each element can be misplaced by a max of k digits before or after
- [ ] Z - TwentySix -> Find Duplicates in O(n) time and O(1) space - Array element values are ≤ Max Index
- [ ] ZA - TwentySeven -> Find 2 repeating elements in a given array - XOR - Given (n+2) elements - 1 ≤ a[i] ≤ n - All elements from 1 to n occurs at least once (Except the 2 numbers that occurs twice)
- [ ] ZB - TwentyEight -> Rotate an array of size n by d elements - Left rotation - Beginning to End - Juggling Algorithm
- [ ] ZC - TwentyNine -> Sort array in wave form - Even position number
- [ ] ZD - Thirty -> Next least greater number to the given number, input as digit array - with same digits
- [ ] ZE - ThirtyOne -> Trapping Rain Water Problem
- [ ] ZF - ThirtyTwo -> No.of Triangles that can be formed
- [ ] ZG - ThirtyThree -> Smallest number that can't be formed by sum of given numbers
- [ ] ZH - ThirtyFour -> Rearrange such that a[i] becomes a[a[i]]
- [ ] ZI - ThirtyFive -> Rotate Matrix by 90 degree - anti-clockwise 
- [ ] ZJ - ThirtySix -> Count number of occurrences (or frequency) in a sorted array
- [ ] ZK - ThirtySeven -> Find Sub Array whose sum is equals zero - reduced time complexity
- [ ] ZL - ThirtyEight -> Largest sub array with equal no.of zeros and ones - my way
- [ ] ZM - ThirtyNine -> Find Duplicates in O(n) time and O(1) space - Array element values are ≤ Max Index - GFG
- [ ] ZN - Forty -> Rotate an array of size n by d elements - Left rotation - Beginning to End 

## Tree Problems
- [ ] A - One -> Size of a Binary Tree
- [ ] B - Two -> Identical or not
- [ ] C - Three -> Mirror Tree
- [ ] D - Four -> Level Order Traversal
- [ ] E - Five -> Lowest Common Ancestor (LCA) - BST
- [ ] F - Six -> Lowest Common Ancestor (LCA) - Binary Tree
- [ ] G - Seven -> Binary Tree into DLL - IN order - InPlace conversion
- [ ] H - Eight -> Diameter of the Binary Tree
- [ ] I - Nine -> Find the level of a given node
- [ ] J - Ten -> Print nodes at k distance form root
- [ ] K - Eleven -> Print nodes at K distance from any node in BT
- [ ] L - Twelve -> Vertical Tree Order Traversal
- [ ] M - Thirteen -> Vertical Sum of the Binary Tree
- [ ] N - Fourteen -> Sum Tree or not
- [ ] O - Fifteen -> Top View
- [ ] P - Sixteen -> Bottom View
- [ ] Q - Seventeen -> Left View
- [ ] R - Eighteen -> Remove all nodes whose length = K in BT.
- [ ] S - Nineteen -> One BT is a sub tree of another BT or not
- [ ] T - Twenty -> Cousin Nodes or not
- [ ] U - TwentyOne -> Balanced BST construction from a sorted List
- [ ] V - TwentyTwo -> Unbalanced BST into Balanced BST
- [ ] W - TwentyThree -> Print all paths possible from root to all leaves
- [ ] X - TwentyFour -> Spiral Level Order Traversal
- [ ] Y - TwentyFive -> BT construction from the given POST and IN Order
- [ ] Z - TwentySix -> All nodes at K distance from leaf
- [ ] ZA - TwentySeven -> Expression Evaluation
- [ ] ZB - TwentyEight -> Extreme nodes of each level in alternating order
- [ ] ZC - TwentyNine -> Diagonal Traversal BT
- [ ] ZD - Thirty -> BT to a BT that holds Child sum property
- [ ] ZE - ThirtyOne -> Multiplication of Sums of data of leaves at same level
- [ ] ZF - ThirtyTwo -> Multiplication of Sums of data at same level
- [ ] ZG - ThirtyThree -> Max of all differences of a node and it's ancestors BT
- [ ] ZH - ThirtyFour -> Serialization and Deserialization BT
- [ ] ZI - ThirtyFive -> Serialization and Deserialization n-ary Tree
- [ ] ZJ - ThirtySix -> Tree from ancestor Matrix
- [ ] ZK - ThirtySeven -> Complete Binary Tree from a LL
- [ ] ZL - ThirtyEight -> Find the next right node of a given node in the same level
- [ ] ZM - ThirtyNine -> Boundary Traversal
- [ ] ZN - Forty -> Convert a given tree into sum tree
- [ ] ZO - FortyOne -> Check if Foldable or not
- [ ] ZP - FortyTwo -> Check if removing an edge will cut into two equal halves
- [ ] ZQ - FortyThree -> Locking and Unlocking a Node - Design Problem
- [ ] ZR - FortyFour -> Reverse Alternate Levels of a perfect BT
- [ ] ZS - FortyFive -> Custom Tree Print Problem
- [ ] ZT - FortySix -> Threaded BT
- [ ] ZU - FortySeven -> Remove all paths whose length < K in BT. -> Subsection of 18th Problem
- [ ] ZV - FortyEight -> BT construction from the given PRE and IN Order -> Subsection of 25th Problem

## Linked List Problems
- [ ] A - One -> Reverse a LL
- [ ] B - Two -> Middle of a LL
- [ ] C - Three -> Kth node from the end of the LL
- [ ] D - Four -> Detect loop in LL
- [ ] E - Five -> Find the start of the Loop in the LL with Loop
- [ ] F - Six -> 2 LL merge at a point, find that point
- [ ] G - Seven -> Alternating Split
- [ ] H - Eight -> Clone a LL that contains Random Pointer (Custom LL)
- [ ] I - Nine -> Palindrome of a LL
- [ ] J - Ten -> Merge 2 Sorted LL into one Sorted LL
- [ ] K - Eleven -> Merge K sorted LL of size N into single Sorted LL of size kn
- [ ] L - Twelve -> Merge sort on LL
- [ ] M - Thirteen -> LL with arb-pointer pointing to greatest in the right side of the current node
- [ ] N - Fourteen -> Memory efficient DLL
- [ ] O - Fifteen -> Sort a LL with 0s, 1s and 2s
- [ ] P - Sixteen -> Add 1 to number represented as LL
- [ ] Q - Seventeen -> Merge K sorted LL of size N into single Sorted LL of size kn - Better complexity

## Stack Problems
- [ ] A - One -> Stack using Queues
- [ ] B - Two -> getMin @ O(1)
- [ ] C - Three -> Reverse a Stack
- [ ] D - Four -> closest greater element to the right
- [ ] E - Five -> Overlapping Intervals
- [ ] F - Six -> Balancing Parenthesis
- [ ] G - Seven -> Stock Span Problem
- [ ] H - Eight -> Min no.of bracket reversals req to make the eqn balanced
- [ ] I - Nine -> find duplicate parenthesis present or not
- [ ] J - Ten -> Celebrity Problem

## Queue Problems
- [ ] A - One -> Circular tour that visit all gasoline stations before running out of gas

## Dynamic Programming
- [ ] A - One -> [Maximum Sum Sub array](https://youtu.be/2MRsqeRunrE)
- [ ] B - Two -> Maximum Sum Increasing Sub Sequence [OR] Longest increasing Sub Sequence
- [ ] C - Three -> Longest Sub Sequence in an array such that the element are consecutive
- [ ] D - Four -> In a Binary Matrix, Max Square Matrix with all 1s
- [ ] E - Five -> Kth Ugly Number
- [ ] F - Six -> Longest Increasing Sub Sequence
- [ ] G - Seven -> Longest Decreasing Sub Sequence
- [ ] H - Eight -> Perfect Hill Sequence
- [ ] I - Nine -> Edit Distance
- [ ] J - Ten -> Largest Sum Independent set in a Binary Tree
- [ ] K - Eleven -> Find n-bit integer that doesn't have 2 consecutive zeros
- [ ] L - Twelve -> Word breaking problem
- [ ] M - Thirteen -> Partition Problem - Sub Set Sum Problem
- [ ] N - Fourteen -> Longest Palindromic sub sequence
- [ ] O - Fifteen -> Steps 1 or 2 to reach n
- [ ] P - Sixteen -> Longest non overlapping repeating sub string
- [ ] Q - Seventeen -> Min cost to make strings(x and y) equal, del(x) -> S, del(y) -> P
- [ ] R - Eighteen -> No.of times a string appeared as Sub Sequence in other string
- [ ] S - Nineteen -> No.of ways to fill 2xn with 2x1
- [ ] T - Twenty -> Given a Cost matrix, min cost to reach (m-1,n-1) from (0,0), allowed movements -> left, right, diagonally down
- [ ] U - TwentyOne -> K palindrome - If string becomes palindrome or not by doing atmost k deletions
- [ ] V - TwentyTwo -> Longest Common Sub Sequence
- [ ] W - TwentyThree -> Sum of all digits from 1 to n
- [ ] X - TwentyFour -> Given a string of digits, sub string length = 2k, sum of left k = sum of right k
- [ ] Y - TwentyFive -> Given a BT, find Largest Independent Set
- [ ] Z - TwentySix -> Cutting Rod
- [ ] ZA - TwentySeven -> Longest Palindromic sub string
- [ ] ZB - TwentyEight -> Count all Palindromic sub string in a string
- [ ] ZC - TwentyNine -> Count all distinct Palindromic sub string in a string
- [ ] ZD - Thirty -> Rectangular grid 2xn, max sum such that no 2 chosen digit are adj -> vertically, horizontally, diagonally
- [ ] ZE - ThirtyOne -> Arrays A -> m, B -> n, (m>n) insert(m-n) 0s in B such that dot product is max
- [ ] ZF - ThirtyTwo -> Largest Independent Set
- [ ] ZG - ThirtyThree -> Egg Dropping Problem
- [ ] ZH - ThirtyFour -> No.of Non-decreasing numbers with n digits
- [ ] ZI - ThirtyFive -> Weighted Job Scheduling
- [ ] ZJ - ThirtySix -> Count no.of ways to reach a score in a given game, player can score 2, 4 or 6 points
- [ ] ZK - ThirtySeven -> Max coins by busting balloons
- [ ] ZL - ThirtyEight -> Max points in the grid using 2 traversals
- [ ] ZM - ThirtyNine -> Sub Set Sum Problem
- [ ] ZN - Forty -> Matrix Chaining - Results Upper triangular Matrix
- [ ] ZO - FortyOne -> Longest Common Sub Sequence
- [ ] ZP - FortyTwo -> Multi Stage Graph
- [ ] ZQ - FortyThree -> 0/1 Knapsack
- [ ] ZR - FortyFour -> Travelling Sales man (TSP) - DFS based - Hamiltonian Cycle + MIN Cost
- [ ] ZS - FortyFive -> All Pair Shortest path - Floyd Warshall's
- [ ] ZT - FortySix -> Matrix Chaining - Top Down 
- [ ] ZU - FortySeven -> Coin Change Problem
- [ ] ZV - FortyEight -> Longest Palindromic sub string - Less Space Complexity
- [ ] ZW - FortyNine -> No.of Non-decreasing numbers with n digits - Less space

## Greedy Problems
- [ ] A - One -> n different ropes of different length, tie them up into a single rope with Min cost.
- [ ] B - Two -> Maximum Non Overlapping Intervals
- [ ] C - Three -> Min no.of platforms required to station all trains without collision
- [ ] D - Four -> Rearrange the characters in the string such that same characters become d-distance away from each other.
- [ ] E - Five -> Dijkstra's Algorithm
- [ ] F - Six -> Fractional Knapsack
- [ ] G - Seven -> Huffman's Coding
- [ ] H - Eight -> Job Sequencing with Deadlines
- [ ] I - Nine -> Spanning Trees and kirchhoff's theorem
- [ ] J - Ten -> Minimum Spanning Tree - Prim's
- [ ] K - Eleven -> Kruskal's Algorithm
- [ ] L - Twelve -> Optimal Merge Patterns

## Divide and Conquer
- [ ] A - One -> Find the element that occurs more than n/2 times - Sorted Array.
- [ ] B - Two -> Bolt and Nuts
- [ ] C - Three -> Implement pow()
- [ ] D - Four -> Search an element in a sorted Rotated Array
- [ ] E - Five -> Count Inversions in an array
- [ ] F - Six -> Missing number in arithmetic progression
- [ ] G - Seven -> Array containing 0s before 1s, count 1s
- [ ] H - Eight -> Array has 2n elements -> `a1, a2, a3, .., an, b1, b2, .. , bn` -> shuffle -> `a1, b1, a2, b2, .., an, bn`
- [ ] I - Nine -> Sorted Array of non-repeating elements, find if there's `i` for which `a[i] = i`
- [ ] J - Ten -> `a[0]..a[i]` -> increasing, `a[i+1]..a[n]` -> decreasing, find i
- [ ] K - Eleven -> search for an element in a row-wise and column-wise sorted 2d array.
- [ ] L - Twelve -> External Sorting
- [ ] M - Thirteen -> Find median of 2 sorted arrays
- [ ] N - Fourteen -> Find Peek Element
- [ ] O - Fifteen -> Get first 1.

## Bit Manipulation
- [ ] A - One -> Kth bit is set or not
- [ ] B - Two -> set Kth Bit of a number
- [ ] C - Three -> clear Kth bit of a number
- [ ] D - Four -> Toggle Kth bit of a number
- [ ] E - Five -> count the no.of set bits of a number
- [ ] F - Six -> power of 2 or not
- [ ] G - Seven -> next higher number of the given number which is a power of 2
- [ ] H - Eight -> power of 4 or not
- [ ] I - Nine -> Multiply with 7 without using `*`
- [ ] J - Ten -> Check if a Number is Odd or Even using Bitwise Operators

## Mathematical
- [ ] A - One -> Prime or not
- [ ] B - Two -> Print prime upto n - Sieve of Eratosthenes Algorithm
- [ ] C - Three -> Lucky number or not

## Hashing
- [ ] A - One -> check if the array has duplicate entries at K distance or not
- [ ] B - Two -> check if 2 sets are disjoint or not
- [ ] C - Three -> Group all occurrences of elements order by their 1st occurrence.
- [ ] D - Four -> Given an array A, count the distinct elements in all windows of size K
- [ ] E - Five -> Given an array and a range (low, high). Find the elements that are in the range but not in the array.
- [ ] F - Six -> Find the no.of sub arrays with sum zero
- [ ] G - Seven -> Find 4 elements i, j, k & l -> such that `i + j = k + l`

## Strings
- [ ] A - One -> Find a max occurring character in a given array.
- [ ] B - Two -> Remove duplicates in a given string
- [ ] C - Three -> Check if given 2 strings are rotations of each other
- [ ] D - Four -> Reverse the words in the given sentence
- [ ] E - Five -> Reverse a given string
- [ ] F - Six -> Check if palindrome
- [ ] G - Seven -> Find 1st non-repeating character in the given string
- [ ] H - Eight -> Run length encoding
- [ ] I - Nine -> Anagrams
- [ ] J - Ten -> Excel column name for a given excel column number (MS Excel)
- [ ] K - Eleven -> Find a smallest window in a string containing all characters of another string
- [ ] L - Twelve -> Find 1s non-repeating character in a stream of characters
- [ ] M - Thirteen -> All combinations of strings used to dail a number (Old Phone Key pad)
- [ ] N - Fourteen -> Min no.of palindromic sub-sequences to be removed to empty a binary string
- [ ] O - Fifteen -> Check if given sequence of moves for robot is circular or not
- [ ] P - Sixteen -> Min and Max of an array using min no.of comparisons
- [ ] Q - Seventeen -> Convert one string to another using min no.of given operations
- [ ] R - Eighteen -> Print concatenation of zig-zack string in k-rows
- [ ] S - Nineteen -> Remove adj duplicate characters in a given string
- [ ] T - Twenty -> Min no.of palindromic sub-sequences to be removed to empty a binary string - Tournament Method

## Pattern Matching
- [ ] A - One -> Find all occurrences of str2 in str1 - Brute force
- [ ] B - Two -> Knuth Morris Pratt Algorithm
- [ ] C - Three -> Boyer's Moore String Matching Algorithm
- [ ] D - Four -> Rabin-Karp String Matching Algorithm
- [ ] E - Five -> Find all occurrences of a given word in a matrix

## Heaps
- [ ] A - One -> Finding the max element in MIN heap
- [ ] B - Two -> Deleting arb element in MIN heap
- [ ] C - Three -> K-Largest elements from an array
- [ ] D - Four -> Median in a stream of numbers
- [ ] E - Five -> Given K-sorted list, find minimum range to which at least on number belongs from every list. - All list are of same size
- [ ] F - Six -> Convert MAX heap into MIN Heap
- [ ] G - Seven -> Print out all integers of the form `a^3+b^3` where a & b are integers b/w 0 & n in sorted order.
- [ ] H - Eight -> Convert BST to MAX Heap
- [ ] I - Nine -> Find the Kth largest element in a stream
- [ ] J - Ten -> Tournament Tree
- [ ] K - Eleven -> Print all elements in sorted order in row wise and column wise sorted matrix
- [ ] L - Twelve -> Sort a nearly sorted array
- [ ] M - Thirteen -> Given n ropes with different length, connect with minimum cost.
- [ ] N - Fourteen -> Check if the given binary tree is a max heap or not.
- [ ] O - Fifteen -> Given K-sorted arrays of size n-each, merge them. - different sized inner lists
- [ ] P - Sixteen -> Delete root from a heap.

## Back Tracking
- [ ] A - One -> Print all permutations of given string
- [ ] B - Two -> Print all the strings of n-bits
- [ ] C - Three -> N-Queens Problem
- [ ] D - Four -> Rat in Maze
- [ ] E - Five -> Knight Tour Problem
- [ ] F - Six -> Find subset of elements that are selected from a given set whose sum adds upto a given number `k` // Subset Sum Problem - Using Backtracking
- [ ] G - Seven -> SUDOKU
- [ ] H - Eight -> N-Queens Problem - Easy way

## Graph Problems
- [ ] A - One -> DFS
- [ ] B - Two -> BFS
- [ ] C - Three -> Find if there's a path between vi and vj in a directed graph
- [ ] D - Four -> Undirected Graph, cycle or not
- [ ] E - Five -> Bipartite or not
- [ ] F - Six -> Detect a cycle in a directed graph
- [ ] G - Seven -> Print all jumping numbers smaller than or equal to given value(k)
- [ ] H - Eight -> Single source shortest path - DAG
- [ ] I - Nine -> Longest Path in DAG, no weights
- [ ] J - Ten -> Find Articulation Point / Cut Vertex, Undirected
- [ ] K - Eleven -> Longest Path in DAG, with weights
- [ ] L - Twelve -> Topological sort